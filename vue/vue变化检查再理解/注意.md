1. Observe类中，dep实例化的位置对更新的影响
```js
class Observe {
    constructor(data) {
        this.__ob__ = this
        this.dep = new Dep()
        /**如果是放在这儿
         * 1. 首先在get过程收集依赖的时候，会收集当前target下所有key对应的watcher
         * 2. 在set的时候，也会通知当前target下所有key对应的watcher去执行更新操作
         * 3. 这个较之于下面那个，定位得稍微粗略一点
         * **/
        if (Array.isArray(data)) {
            this.observeArray(data)
        } else {
            this.walk(data)
        }
    }
    // xxx
    defineReactive(target, key, value) {
        let dep = new Dep()
        /**如果是放在这儿
         * 1. 首先在get过程收集依赖的时候，只会收集当前key对应的watcher
         * 2. 在set的时候，也只会通知当前key对应的watcher去执行更新操作
         * 3. 这个较之于上面那个，定位得要细致一点
         * **/
        Object.defineProperty(target, key, {
            // enumerable: true,
            configurable: true,
            get: function() {
                dep.depend()
                return value
            },
            set: function(newVal) {
                if (value === newVal) {
                    return
                }
                value = newVal
                observe(newVal)
                dep.notify()
            }
        })
    }
}
```